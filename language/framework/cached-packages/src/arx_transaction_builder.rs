// Copyright (c) Arx
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Arx transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `ol-transaction-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
use arx_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    /// Offers rotation capability on behalf of `account` to the account at address `recipient_address`.
    /// An account can delegate its rotation capability to only one other address at one time. If the account
    /// has an existing rotation capability offer, calling this function will update the rotation capability offer with
    /// the new `recipient_address`.
    /// Here, `rotation_capability_sig_bytes` signature indicates that this key rotation is authorized by the account owner,
    /// and prevents the classic "time-of-check time-of-use" attack.
    /// For example, users usually rely on what the wallet displays to them as the transaction's outcome. Consider a contract that with 50% probability
    /// (based on the current timestamp in Move), rotates somebody's key. The wallet might be unlucky and get an outcome where nothing is rotated,
    /// incorrectly telling the user nothing bad will happen. But when the transaction actually gets executed, the attacker gets lucky and
    /// the execution path triggers the account key rotation.
    /// We prevent such attacks by asking for this extra signature authorizing the key rotation.
    ///
    /// @param rotation_capability_sig_bytes is the signature by the account owner's key on `RotationCapabilityOfferProofChallengeV2`.
    /// @param account_scheme is the scheme of the account (ed25519 or multi_ed25519).
    /// @param account_public_key_bytes is the public key of the account owner.
    /// @param recipient_address is the address of the recipient of the rotation capability - note that if there's an existing rotation capability
    /// offer, calling this function will replace the previous `recipient_address` upon successful verification.
    AccountOfferRotationCapability {
        rotation_capability_sig_bytes: Vec<u8>,
        account_scheme: u8,
        account_public_key_bytes: Vec<u8>,
        recipient_address: AccountAddress,
    },

    /// Offers signer capability on behalf of `account` to the account at address `recipient_address`.
    /// An account can delegate its signer capability to only one other address at one time.
    /// `signer_capability_key_bytes` is the `SignerCapabilityOfferProofChallengeV2` signed by the account owner's key
    /// `account_scheme` is the scheme of the account (ed25519 or multi_ed25519).
    /// `account_public_key_bytes` is the public key of the account owner.
    /// `recipient_address` is the address of the recipient of the signer capability - note that if there's an existing
    /// `recipient_address` in the account owner's `SignerCapabilityOffer`, this will replace the
    /// previous `recipient_address` upon successful verification (the previous recipient will no longer have access
    /// to the account owner's signer capability).
    AccountOfferSignerCapability {
        signer_capability_sig_bytes: Vec<u8>,
        account_scheme: u8,
        account_public_key_bytes: Vec<u8>,
        recipient_address: AccountAddress,
    },

    /// Revoke any rotation capability offer in the specified account.
    AccountRevokeAnyRotationCapability {},

    /// Revoke any signer capability offer in the specified account.
    AccountRevokeAnySignerCapability {},

    /// Revoke the rotation capability offer given to `to_be_revoked_recipient_address` from `account`
    AccountRevokeRotationCapability {
        to_be_revoked_address: AccountAddress,
    },

    /// Revoke the account owner's signer capability offer for `to_be_revoked_address` (i.e., the address that
    /// has a signer capability offer from `account` but will be revoked in this function).
    AccountRevokeSignerCapability {
        to_be_revoked_address: AccountAddress,
    },

    /// Generic authentication key rotation function that allows the user to rotate their authentication
    /// key from any scheme to any scheme.
    /// To authorize the rotation, we need two signatures:
    /// - the first signature `cap_rotate_key` refers to the signature by the account owner's current
    ///   key on a valid `RotationProofChallenge`,
    /// demonstrating that the user intends to and has the capability to rotate the authentication key
    /// of this account;
    /// - the second signature `cap_update_table` refers to the signature by the new key (that the
    /// account owner wants to rotate to) on a valid `RotationProofChallenge`, demonstrating that the
    /// user owns the new private key, and has the authority to update the `OriginatingAddress` map
    /// with the new address mapping <new_address, originating_address>.
    /// To verify these two signatures, we need their corresponding public key and public key scheme:
    /// we use `from_scheme` and `from_public_key_bytes` to verify `cap_rotate_key`, and `to_scheme`
    /// and `to_public_key_bytes` to verify `cap_update_table`.
    /// A scheme of 0 refers to an Ed25519 key and a scheme of 1 refers to Multi-Ed25519 keys.
    /// `originating address` refers to an account's original/first address.
    ///
    /// Here is an example attack if we don't ask for the second signature `cap_update_table`:
    /// Alice has rotated her account addr_a to new_addr_a. As a result, the following entry is created, to help Alice when recovering her wallet:
    /// OriginatingAddress[new_addr_a] -> addr_a
    /// Alice has had bad day: her laptop blew up and she needs to reset her account on a new one.
    /// (Fortunately, she still has her secret key new_sk_a associated with her new address new_addr_a, so she can do this.)
    ///
    /// But Bob likes to mess with Alice.
    /// Bob creates an account addr_b and maliciously rotates it to Alice's new address new_addr_a. Since we are no longer checking a PoK,
    /// Bob can easily do this.
    ///
    /// Now, the table will be updated to make Alice's new address point to Bob's address: OriginatingAddress[new_addr_a] -> addr_b.
    /// When Alice recovers her account, her wallet will display the attacker's address (Bob's) addr_b as her address.
    /// Now Alice will give addr_b to everyone to pay her, but the money will go to Bob.
    ///
    /// Because we ask for a valid `cap_update_table`, this kind of attack is not possible. Bob would not have the secret key of Alice's address
    /// to rotate his address to Alice's address in the first place.
    AccountRotateAuthenticationKey {
        from_scheme: u8,
        from_public_key_bytes: Vec<u8>,
        to_scheme: u8,
        to_public_key_bytes: Vec<u8>,
        cap_rotate_key: Vec<u8>,
        cap_update_table: Vec<u8>,
    },

    AccountRotateAuthenticationKeyWithRotationCapability {
        rotation_cap_offerer_address: AccountAddress,
        new_scheme: u8,
        new_public_key_bytes: Vec<u8>,
        cap_update_table: Vec<u8>,
    },

    /// Batch version of Arx transfer.
    ArxAccountBatchTransfer {
        recipients: Vec<AccountAddress>,
        amounts: Vec<u64>,
    },

    /// Batch version of transfer_coins.
    ArxAccountBatchTransferCoins {
        coin_type: TypeTag,
        recipients: Vec<AccountAddress>,
        amounts: Vec<u64>,
    },

    /// Basic account creation methods.
    ArxAccountCreateAccount {
        auth_key: AccountAddress,
    },

    /// Set whether `account` can receive direct transfers of coins that they have not explicitly registered to receive.
    ArxAccountSetAllowDirectCoinTransfers {
        allow: bool,
    },

    /// Convenient function to transfer Arx to a recipient account that might not exist.
    /// This would create the recipient account first, which also registers it to receive Arx, before
    /// transferring.
    ArxAccountTransfer {
        to: AccountAddress,
        amount: u64,
    },

    /// Convenient function to transfer a custom CoinType to a recipient account that might not exist.
    /// This would create the recipient account first and register it to receive the CoinType, before transferring.
    ArxAccountTransferCoins {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Claim the delegated mint capability and destroy the delegated token.
    ArxCoinClaimMintCapability {},

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create delegated token for the address so the account could claim MintCapability later.
    ArxCoinDelegateMintCapability {
        to: AccountAddress,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create new coins and deposit them into dst_addr's account.
    ArxCoinMint {
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Same as `publish_package` but as an entry function which can be called as a transaction. Because
    /// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
    CodePublishPackageTxn {
        metadata_serialized: Vec<u8>,
        code: Vec<Vec<u8>>,
    },

    /// Transfers `amount` of coins `CoinType` from `from` to `to`.
    CoinTransfer {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// Upgrade total supply to use a parallelizable implementation if it is
    /// available.
    CoinUpgradeSupply {
        coin_type: TypeTag,
    },

    GovernanceAddApprovedScriptHashScript {
        proposal_id: u64,
    },

    /// Create a single-step proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal
    /// is resolved, only the exact script with matching hash can be successfully executed.
    GovernanceCreateProposal {
        stake_pool: AccountAddress,
        execution_hash: Vec<u8>,
        metadata_location: Vec<u8>,
        metadata_hash: Vec<u8>,
    },

    /// Create a single-step or multi-step proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal
    /// is resolved, only the exact script with matching hash can be successfully executed.
    GovernanceCreateProposalV2 {
        stake_pool: AccountAddress,
        execution_hash: Vec<u8>,
        metadata_location: Vec<u8>,
        metadata_hash: Vec<u8>,
        is_multi_step_proposal: bool,
    },

    /// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
    GovernanceVote {
        stake_pool: AccountAddress,
        proposal_id: u64,
        should_pass: bool,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Claim the delegated mint capability and destroy the delegated token.
    LuxCoinClaimMintCapability {},

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create delegated token for the address so the account could claim MintCapability later.
    LuxCoinDelegateMintCapability {
        to: AccountAddress,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create new coins and deposit them into dst_addr's account.
    LuxCoinMint {
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Claim the delegated mint capability and destroy the delegated token.
    NoxCoinClaimMintCapability {},

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create delegated token for the address so the account could claim MintCapability later.
    NoxCoinDelegateMintCapability {
        to: AccountAddress,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create new coins and deposit them into dst_addr's account.
    NoxCoinMint {
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Entry function that can be used to transfer, if allow_ungated_transfer is set true.
    ObjectTransferCall {
        object_id: AccountAddress,
        to: AccountAddress,
    },

    /// Creates a new resource account and rotates the authentication key to either
    /// the optional auth key if it is non-empty (though auth keys are 32-bytes)
    /// or the source accounts current auth key.
    ResourceAccountCreateResourceAccount {
        seed: Vec<u8>,
        optional_auth_key: Vec<u8>,
    },

    /// Creates a new resource account, transfer the amount of coins from the origin to the resource
    /// account, and rotates the authentication key to either the optional auth key if it is
    /// non-empty (though auth keys are 32-bytes) or the source accounts current auth key. Note,
    /// this function adds additional resource ownership to the resource account and should only be
    /// used for resource accounts that need access to Coin<ArxCoin>.
    ResourceAccountCreateResourceAccountAndFund {
        seed: Vec<u8>,
        optional_auth_key: Vec<u8>,
        fund_amount: u64,
    },

    /// Creates a new resource account, publishes the package under this account transaction under
    /// this account and leaves the signer cap readily available for pickup.
    ResourceAccountCreateResourceAccountAndPublishPackage {
        seed: Vec<u8>,
        metadata_serialized: Vec<u8>,
        code: Vec<Vec<u8>>,
    },

    /// Add forma coins to an existing solaris. External.
    SolarisAddCoins {
        coin_type: TypeTag,
        amount: u64,
    },

    /// Initialises a new solaris assigned to the provided owner.
    SolarisInitializeOwner {
        coin_type: TypeTag,
    },

    /// Reactivate forma coins pending unlock.
    SolarisReactivateCoins {
        coin_type: TypeTag,
        amount: u64,
    },

    /// Remove forma coins from an existing solaris. External.
    SolarisRemoveCoins {
        coin_type: TypeTag,
        amount: u64,
    },

    /// Withdraw unlocked coins from an existing solaris. External.
    SolarisWithdrawCoins {
        coin_type: TypeTag,
        amount: u64,
    },

    /// Join the subsidialis with a pre-existing solaris of designated coin type.
    /// It is necessary to join the subsidialis in order to receive seignorage rewards.
    SubsidialisJoin {
        coin_type: TypeTag,
    },

    /// Leave the subsidialis with a pre-existing solaris of designated coin type.
    /// It is necessary to leave the subsidialis in order for removed forma coins to become unlocked.
    SubsidialisLeave {
        coin_type: TypeTag,
    },

    /// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
    ValidatorIncreaseLockup {},

    /// Initialize the validator account and give ownership to the signing account
    /// except it leaves the ValidatorConfig to be set by another entity.
    /// Note: this triggers setting the operator and owner, set it to the account's address
    /// to set later.
    ValidatorInitializeStakeOwner {
        initial_stake_amount: u64,
        operator: AccountAddress,
        vault: AccountAddress,
    },

    /// Initialize the validator account and give ownership to the signing account.
    ValidatorInitializeValidator {
        consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
        network_addresses: Vec<u8>,
        fullnode_addresses: Vec<u8>,
    },

    /// This can only called by the operator of the validator/staking lock.
    ValidatorJoinValidatorSet {
        lock_address: AccountAddress,
    },

    /// Request to have `lock_address` leave the validator set. The validator is only actually removed
    /// from the set when the next epoch starts. The last validator in the set cannot leave. This is
    /// an edge case that should never happen as long as the network is still operational.
    ///
    /// Can only be called by the operator of the validator/staking lock.
    ValidatorLeaveValidatorSet {
        lock_address: AccountAddress,
    },

    /// Add `amount` of coins from the `account` owning the StakeLock.
    ValidatorLockStake {
        amount: u64,
    },

    /// Move `amount` of coins from pending_inactive to active.
    ValidatorReactivateStake {
        amount: u64,
    },

    /// Rotate the consensus key of the validator, it'll take effect in next epoch.
    ValidatorRotateConsensusKey {
        lock_address: AccountAddress,
        new_consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
    },

    /// Allows an owner to change the operator of the stake lock.
    ValidatorSetOperator {
        new_operator: AccountAddress,
    },

    /// Allows an owner to change the vault of the stake lock.
    ValidatorSetVault {
        new_vault: AccountAddress,
    },

    /// Similar to unlock_with_cap but will use ownership capability from the signing account.
    ValidatorUnlock {
        amount: u64,
    },

    /// Update the network and full node addresses of the validator. This only takes effect in the
    /// next epoch.
    ValidatorUpdateNetworkInfo {
        lock_address: AccountAddress,
        new_network_addresses: Vec<u8>,
        new_fullnode_addresses: Vec<u8>,
    },

    /// Withdraw from `account`'s inactive stake.
    ValidatorWithdraw {
        withdraw_amount: u64,
    },

    /// Updates the major version to a larger version.
    /// This can be called by on chain governance.
    VersionSetVersion {
        major: u64,
    },
}

impl EntryFunctionCall {
    /// Build an Arx `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            AccountOfferRotationCapability {
                rotation_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            } => account_offer_rotation_capability(
                rotation_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            ),
            AccountOfferSignerCapability {
                signer_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            } => account_offer_signer_capability(
                signer_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            ),
            AccountRevokeAnyRotationCapability {} => account_revoke_any_rotation_capability(),
            AccountRevokeAnySignerCapability {} => account_revoke_any_signer_capability(),
            AccountRevokeRotationCapability {
                to_be_revoked_address,
            } => account_revoke_rotation_capability(to_be_revoked_address),
            AccountRevokeSignerCapability {
                to_be_revoked_address,
            } => account_revoke_signer_capability(to_be_revoked_address),
            AccountRotateAuthenticationKey {
                from_scheme,
                from_public_key_bytes,
                to_scheme,
                to_public_key_bytes,
                cap_rotate_key,
                cap_update_table,
            } => account_rotate_authentication_key(
                from_scheme,
                from_public_key_bytes,
                to_scheme,
                to_public_key_bytes,
                cap_rotate_key,
                cap_update_table,
            ),
            AccountRotateAuthenticationKeyWithRotationCapability {
                rotation_cap_offerer_address,
                new_scheme,
                new_public_key_bytes,
                cap_update_table,
            } => account_rotate_authentication_key_with_rotation_capability(
                rotation_cap_offerer_address,
                new_scheme,
                new_public_key_bytes,
                cap_update_table,
            ),
            ArxAccountBatchTransfer {
                recipients,
                amounts,
            } => arx_account_batch_transfer(recipients, amounts),
            ArxAccountBatchTransferCoins {
                coin_type,
                recipients,
                amounts,
            } => arx_account_batch_transfer_coins(coin_type, recipients, amounts),
            ArxAccountCreateAccount { auth_key } => arx_account_create_account(auth_key),
            ArxAccountSetAllowDirectCoinTransfers { allow } => {
                arx_account_set_allow_direct_coin_transfers(allow)
            },
            ArxAccountTransfer { to, amount } => arx_account_transfer(to, amount),
            ArxAccountTransferCoins {
                coin_type,
                to,
                amount,
            } => arx_account_transfer_coins(coin_type, to, amount),
            ArxCoinClaimMintCapability {} => arx_coin_claim_mint_capability(),
            ArxCoinDelegateMintCapability { to } => arx_coin_delegate_mint_capability(to),
            ArxCoinMint { dst_addr, amount } => arx_coin_mint(dst_addr, amount),
            CodePublishPackageTxn {
                metadata_serialized,
                code,
            } => code_publish_package_txn(metadata_serialized, code),
            CoinTransfer {
                coin_type,
                to,
                amount,
            } => coin_transfer(coin_type, to, amount),
            CoinUpgradeSupply { coin_type } => coin_upgrade_supply(coin_type),
            GovernanceAddApprovedScriptHashScript { proposal_id } => {
                governance_add_approved_script_hash_script(proposal_id)
            },
            GovernanceCreateProposal {
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
            } => governance_create_proposal(
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
            ),
            GovernanceCreateProposalV2 {
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
                is_multi_step_proposal,
            } => governance_create_proposal_v2(
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
                is_multi_step_proposal,
            ),
            GovernanceVote {
                stake_pool,
                proposal_id,
                should_pass,
            } => governance_vote(stake_pool, proposal_id, should_pass),
            LuxCoinClaimMintCapability {} => lux_coin_claim_mint_capability(),
            LuxCoinDelegateMintCapability { to } => lux_coin_delegate_mint_capability(to),
            LuxCoinMint { dst_addr, amount } => lux_coin_mint(dst_addr, amount),
            NoxCoinClaimMintCapability {} => nox_coin_claim_mint_capability(),
            NoxCoinDelegateMintCapability { to } => nox_coin_delegate_mint_capability(to),
            NoxCoinMint { dst_addr, amount } => nox_coin_mint(dst_addr, amount),
            ObjectTransferCall { object_id, to } => object_transfer_call(object_id, to),
            ResourceAccountCreateResourceAccount {
                seed,
                optional_auth_key,
            } => resource_account_create_resource_account(seed, optional_auth_key),
            ResourceAccountCreateResourceAccountAndFund {
                seed,
                optional_auth_key,
                fund_amount,
            } => resource_account_create_resource_account_and_fund(
                seed,
                optional_auth_key,
                fund_amount,
            ),
            ResourceAccountCreateResourceAccountAndPublishPackage {
                seed,
                metadata_serialized,
                code,
            } => resource_account_create_resource_account_and_publish_package(
                seed,
                metadata_serialized,
                code,
            ),
            SolarisAddCoins { coin_type, amount } => solaris_add_coins(coin_type, amount),
            SolarisInitializeOwner { coin_type } => solaris_initialize_owner(coin_type),
            SolarisReactivateCoins { coin_type, amount } => {
                solaris_reactivate_coins(coin_type, amount)
            },
            SolarisRemoveCoins { coin_type, amount } => solaris_remove_coins(coin_type, amount),
            SolarisWithdrawCoins { coin_type, amount } => solaris_withdraw_coins(coin_type, amount),
            SubsidialisJoin { coin_type } => subsidialis_join(coin_type),
            SubsidialisLeave { coin_type } => subsidialis_leave(coin_type),
            ValidatorIncreaseLockup {} => validator_increase_lockup(),
            ValidatorInitializeStakeOwner {
                initial_stake_amount,
                operator,
                vault,
            } => validator_initialize_stake_owner(initial_stake_amount, operator, vault),
            ValidatorInitializeValidator {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => validator_initialize_validator(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            ValidatorJoinValidatorSet { lock_address } => {
                validator_join_validator_set(lock_address)
            },
            ValidatorLeaveValidatorSet { lock_address } => {
                validator_leave_validator_set(lock_address)
            },
            ValidatorLockStake { amount } => validator_lock_stake(amount),
            ValidatorReactivateStake { amount } => validator_reactivate_stake(amount),
            ValidatorRotateConsensusKey {
                lock_address,
                new_consensus_pubkey,
                proof_of_possession,
            } => validator_rotate_consensus_key(
                lock_address,
                new_consensus_pubkey,
                proof_of_possession,
            ),
            ValidatorSetOperator { new_operator } => validator_set_operator(new_operator),
            ValidatorSetVault { new_vault } => validator_set_vault(new_vault),
            ValidatorUnlock { amount } => validator_unlock(amount),
            ValidatorUpdateNetworkInfo {
                lock_address,
                new_network_addresses,
                new_fullnode_addresses,
            } => validator_update_network_info(
                lock_address,
                new_network_addresses,
                new_fullnode_addresses,
            ),
            ValidatorWithdraw { withdraw_amount } => validator_withdraw(withdraw_amount),
            VersionSetVersion { major } => version_set_version(major),
        }
    }

    /// Try to recognize an Arx `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Offers rotation capability on behalf of `account` to the account at address `recipient_address`.
/// An account can delegate its rotation capability to only one other address at one time. If the account
/// has an existing rotation capability offer, calling this function will update the rotation capability offer with
/// the new `recipient_address`.
/// Here, `rotation_capability_sig_bytes` signature indicates that this key rotation is authorized by the account owner,
/// and prevents the classic "time-of-check time-of-use" attack.
/// For example, users usually rely on what the wallet displays to them as the transaction's outcome. Consider a contract that with 50% probability
/// (based on the current timestamp in Move), rotates somebody's key. The wallet might be unlucky and get an outcome where nothing is rotated,
/// incorrectly telling the user nothing bad will happen. But when the transaction actually gets executed, the attacker gets lucky and
/// the execution path triggers the account key rotation.
/// We prevent such attacks by asking for this extra signature authorizing the key rotation.
///
/// @param rotation_capability_sig_bytes is the signature by the account owner's key on `RotationCapabilityOfferProofChallengeV2`.
/// @param account_scheme is the scheme of the account (ed25519 or multi_ed25519).
/// @param account_public_key_bytes is the public key of the account owner.
/// @param recipient_address is the address of the recipient of the rotation capability - note that if there's an existing rotation capability
/// offer, calling this function will replace the previous `recipient_address` upon successful verification.
pub fn account_offer_rotation_capability(
    rotation_capability_sig_bytes: Vec<u8>,
    account_scheme: u8,
    account_public_key_bytes: Vec<u8>,
    recipient_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("offer_rotation_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&rotation_capability_sig_bytes).unwrap(),
            bcs::to_bytes(&account_scheme).unwrap(),
            bcs::to_bytes(&account_public_key_bytes).unwrap(),
            bcs::to_bytes(&recipient_address).unwrap(),
        ],
    ))
}

/// Offers signer capability on behalf of `account` to the account at address `recipient_address`.
/// An account can delegate its signer capability to only one other address at one time.
/// `signer_capability_key_bytes` is the `SignerCapabilityOfferProofChallengeV2` signed by the account owner's key
/// `account_scheme` is the scheme of the account (ed25519 or multi_ed25519).
/// `account_public_key_bytes` is the public key of the account owner.
/// `recipient_address` is the address of the recipient of the signer capability - note that if there's an existing
/// `recipient_address` in the account owner's `SignerCapabilityOffer`, this will replace the
/// previous `recipient_address` upon successful verification (the previous recipient will no longer have access
/// to the account owner's signer capability).
pub fn account_offer_signer_capability(
    signer_capability_sig_bytes: Vec<u8>,
    account_scheme: u8,
    account_public_key_bytes: Vec<u8>,
    recipient_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("offer_signer_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&signer_capability_sig_bytes).unwrap(),
            bcs::to_bytes(&account_scheme).unwrap(),
            bcs::to_bytes(&account_public_key_bytes).unwrap(),
            bcs::to_bytes(&recipient_address).unwrap(),
        ],
    ))
}

/// Revoke any rotation capability offer in the specified account.
pub fn account_revoke_any_rotation_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_any_rotation_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Revoke any signer capability offer in the specified account.
pub fn account_revoke_any_signer_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_any_signer_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Revoke the rotation capability offer given to `to_be_revoked_recipient_address` from `account`
pub fn account_revoke_rotation_capability(
    to_be_revoked_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_rotation_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to_be_revoked_address).unwrap()],
    ))
}

/// Revoke the account owner's signer capability offer for `to_be_revoked_address` (i.e., the address that
/// has a signer capability offer from `account` but will be revoked in this function).
pub fn account_revoke_signer_capability(
    to_be_revoked_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_signer_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to_be_revoked_address).unwrap()],
    ))
}

/// Generic authentication key rotation function that allows the user to rotate their authentication
/// key from any scheme to any scheme.
/// To authorize the rotation, we need two signatures:
/// - the first signature `cap_rotate_key` refers to the signature by the account owner's current
///   key on a valid `RotationProofChallenge`,
/// demonstrating that the user intends to and has the capability to rotate the authentication key
/// of this account;
/// - the second signature `cap_update_table` refers to the signature by the new key (that the
/// account owner wants to rotate to) on a valid `RotationProofChallenge`, demonstrating that the
/// user owns the new private key, and has the authority to update the `OriginatingAddress` map
/// with the new address mapping <new_address, originating_address>.
/// To verify these two signatures, we need their corresponding public key and public key scheme:
/// we use `from_scheme` and `from_public_key_bytes` to verify `cap_rotate_key`, and `to_scheme`
/// and `to_public_key_bytes` to verify `cap_update_table`.
/// A scheme of 0 refers to an Ed25519 key and a scheme of 1 refers to Multi-Ed25519 keys.
/// `originating address` refers to an account's original/first address.
///
/// Here is an example attack if we don't ask for the second signature `cap_update_table`:
/// Alice has rotated her account addr_a to new_addr_a. As a result, the following entry is created, to help Alice when recovering her wallet:
/// OriginatingAddress[new_addr_a] -> addr_a
/// Alice has had bad day: her laptop blew up and she needs to reset her account on a new one.
/// (Fortunately, she still has her secret key new_sk_a associated with her new address new_addr_a, so she can do this.)
///
/// But Bob likes to mess with Alice.
/// Bob creates an account addr_b and maliciously rotates it to Alice's new address new_addr_a. Since we are no longer checking a PoK,
/// Bob can easily do this.
///
/// Now, the table will be updated to make Alice's new address point to Bob's address: OriginatingAddress[new_addr_a] -> addr_b.
/// When Alice recovers her account, her wallet will display the attacker's address (Bob's) addr_b as her address.
/// Now Alice will give addr_b to everyone to pay her, but the money will go to Bob.
///
/// Because we ask for a valid `cap_update_table`, this kind of attack is not possible. Bob would not have the secret key of Alice's address
/// to rotate his address to Alice's address in the first place.
pub fn account_rotate_authentication_key(
    from_scheme: u8,
    from_public_key_bytes: Vec<u8>,
    to_scheme: u8,
    to_public_key_bytes: Vec<u8>,
    cap_rotate_key: Vec<u8>,
    cap_update_table: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&from_scheme).unwrap(),
            bcs::to_bytes(&from_public_key_bytes).unwrap(),
            bcs::to_bytes(&to_scheme).unwrap(),
            bcs::to_bytes(&to_public_key_bytes).unwrap(),
            bcs::to_bytes(&cap_rotate_key).unwrap(),
            bcs::to_bytes(&cap_update_table).unwrap(),
        ],
    ))
}

pub fn account_rotate_authentication_key_with_rotation_capability(
    rotation_cap_offerer_address: AccountAddress,
    new_scheme: u8,
    new_public_key_bytes: Vec<u8>,
    cap_update_table: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key_with_rotation_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&rotation_cap_offerer_address).unwrap(),
            bcs::to_bytes(&new_scheme).unwrap(),
            bcs::to_bytes(&new_public_key_bytes).unwrap(),
            bcs::to_bytes(&cap_update_table).unwrap(),
        ],
    ))
}

/// Batch version of Arx transfer.
pub fn arx_account_batch_transfer(
    recipients: Vec<AccountAddress>,
    amounts: Vec<u64>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_account").to_owned(),
        ),
        ident_str!("batch_transfer").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&recipients).unwrap(),
            bcs::to_bytes(&amounts).unwrap(),
        ],
    ))
}

/// Batch version of transfer_coins.
pub fn arx_account_batch_transfer_coins(
    coin_type: TypeTag,
    recipients: Vec<AccountAddress>,
    amounts: Vec<u64>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_account").to_owned(),
        ),
        ident_str!("batch_transfer_coins").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&recipients).unwrap(),
            bcs::to_bytes(&amounts).unwrap(),
        ],
    ))
}

/// Basic account creation methods.
pub fn arx_account_create_account(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_account").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

/// Set whether `account` can receive direct transfers of coins that they have not explicitly registered to receive.
pub fn arx_account_set_allow_direct_coin_transfers(allow: bool) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_account").to_owned(),
        ),
        ident_str!("set_allow_direct_coin_transfers").to_owned(),
        vec![],
        vec![bcs::to_bytes(&allow).unwrap()],
    ))
}

/// Convenient function to transfer Arx to a recipient account that might not exist.
/// This would create the recipient account first, which also registers it to receive Arx, before
/// transferring.
pub fn arx_account_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_account").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Convenient function to transfer a custom CoinType to a recipient account that might not exist.
/// This would create the recipient account first and register it to receive the CoinType, before transferring.
pub fn arx_account_transfer_coins(
    coin_type: TypeTag,
    to: AccountAddress,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_account").to_owned(),
        ),
        ident_str!("transfer_coins").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Claim the delegated mint capability and destroy the delegated token.
pub fn arx_coin_claim_mint_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_coin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create delegated token for the address so the account could claim MintCapability later.
pub fn arx_coin_delegate_mint_capability(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_coin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create new coins and deposit them into dst_addr's account.
pub fn arx_coin_mint(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("arx_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Same as `publish_package` but as an entry function which can be called as a transaction. Because
/// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
pub fn code_publish_package_txn(
    metadata_serialized: Vec<u8>,
    code: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("code").to_owned(),
        ),
        ident_str!("publish_package_txn").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_serialized).unwrap(),
            bcs::to_bytes(&code).unwrap(),
        ],
    ))
}

/// Transfers `amount` of coins `CoinType` from `from` to `to`.
pub fn coin_transfer(coin_type: TypeTag, to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Upgrade total supply to use a parallelizable implementation if it is
/// available.
pub fn coin_upgrade_supply(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("upgrade_supply").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

pub fn governance_add_approved_script_hash_script(proposal_id: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("governance").to_owned(),
        ),
        ident_str!("add_approved_script_hash_script").to_owned(),
        vec![],
        vec![bcs::to_bytes(&proposal_id).unwrap()],
    ))
}

/// Create a single-step proposal with the backing `stake_pool`.
/// @param execution_hash Required. This is the hash of the resolution script. When the proposal
/// is resolved, only the exact script with matching hash can be successfully executed.
pub fn governance_create_proposal(
    stake_pool: AccountAddress,
    execution_hash: Vec<u8>,
    metadata_location: Vec<u8>,
    metadata_hash: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("governance").to_owned(),
        ),
        ident_str!("create_proposal").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&execution_hash).unwrap(),
            bcs::to_bytes(&metadata_location).unwrap(),
            bcs::to_bytes(&metadata_hash).unwrap(),
        ],
    ))
}

/// Create a single-step or multi-step proposal with the backing `stake_pool`.
/// @param execution_hash Required. This is the hash of the resolution script. When the proposal
/// is resolved, only the exact script with matching hash can be successfully executed.
pub fn governance_create_proposal_v2(
    stake_pool: AccountAddress,
    execution_hash: Vec<u8>,
    metadata_location: Vec<u8>,
    metadata_hash: Vec<u8>,
    is_multi_step_proposal: bool,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("governance").to_owned(),
        ),
        ident_str!("create_proposal_v2").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&execution_hash).unwrap(),
            bcs::to_bytes(&metadata_location).unwrap(),
            bcs::to_bytes(&metadata_hash).unwrap(),
            bcs::to_bytes(&is_multi_step_proposal).unwrap(),
        ],
    ))
}

/// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
pub fn governance_vote(
    stake_pool: AccountAddress,
    proposal_id: u64,
    should_pass: bool,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("governance").to_owned(),
        ),
        ident_str!("vote").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&should_pass).unwrap(),
        ],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Claim the delegated mint capability and destroy the delegated token.
pub fn lux_coin_claim_mint_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("lux_coin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create delegated token for the address so the account could claim MintCapability later.
pub fn lux_coin_delegate_mint_capability(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("lux_coin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create new coins and deposit them into dst_addr's account.
pub fn lux_coin_mint(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("lux_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Claim the delegated mint capability and destroy the delegated token.
pub fn nox_coin_claim_mint_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("nox_coin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create delegated token for the address so the account could claim MintCapability later.
pub fn nox_coin_delegate_mint_capability(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("nox_coin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create new coins and deposit them into dst_addr's account.
pub fn nox_coin_mint(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("nox_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Entry function that can be used to transfer, if allow_ungated_transfer is set true.
pub fn object_transfer_call(object_id: AccountAddress, to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("object").to_owned(),
        ),
        ident_str!("transfer_call").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&object_id).unwrap(),
            bcs::to_bytes(&to).unwrap(),
        ],
    ))
}

/// Creates a new resource account and rotates the authentication key to either
/// the optional auth key if it is non-empty (though auth keys are 32-bytes)
/// or the source accounts current auth key.
pub fn resource_account_create_resource_account(
    seed: Vec<u8>,
    optional_auth_key: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&optional_auth_key).unwrap(),
        ],
    ))
}

/// Creates a new resource account, transfer the amount of coins from the origin to the resource
/// account, and rotates the authentication key to either the optional auth key if it is
/// non-empty (though auth keys are 32-bytes) or the source accounts current auth key. Note,
/// this function adds additional resource ownership to the resource account and should only be
/// used for resource accounts that need access to Coin<ArxCoin>.
pub fn resource_account_create_resource_account_and_fund(
    seed: Vec<u8>,
    optional_auth_key: Vec<u8>,
    fund_amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account_and_fund").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&optional_auth_key).unwrap(),
            bcs::to_bytes(&fund_amount).unwrap(),
        ],
    ))
}

/// Creates a new resource account, publishes the package under this account transaction under
/// this account and leaves the signer cap readily available for pickup.
pub fn resource_account_create_resource_account_and_publish_package(
    seed: Vec<u8>,
    metadata_serialized: Vec<u8>,
    code: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account_and_publish_package").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&metadata_serialized).unwrap(),
            bcs::to_bytes(&code).unwrap(),
        ],
    ))
}

/// Add forma coins to an existing solaris. External.
pub fn solaris_add_coins(coin_type: TypeTag, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("solaris").to_owned(),
        ),
        ident_str!("add_coins").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Initialises a new solaris assigned to the provided owner.
pub fn solaris_initialize_owner(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("solaris").to_owned(),
        ),
        ident_str!("initialize_owner").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Reactivate forma coins pending unlock.
pub fn solaris_reactivate_coins(coin_type: TypeTag, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("solaris").to_owned(),
        ),
        ident_str!("reactivate_coins").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Remove forma coins from an existing solaris. External.
pub fn solaris_remove_coins(coin_type: TypeTag, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("solaris").to_owned(),
        ),
        ident_str!("remove_coins").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Withdraw unlocked coins from an existing solaris. External.
pub fn solaris_withdraw_coins(coin_type: TypeTag, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("solaris").to_owned(),
        ),
        ident_str!("withdraw_coins").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Join the subsidialis with a pre-existing solaris of designated coin type.
/// It is necessary to join the subsidialis in order to receive seignorage rewards.
pub fn subsidialis_join(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("subsidialis").to_owned(),
        ),
        ident_str!("join").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Leave the subsidialis with a pre-existing solaris of designated coin type.
/// It is necessary to leave the subsidialis in order for removed forma coins to become unlocked.
pub fn subsidialis_leave(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("subsidialis").to_owned(),
        ),
        ident_str!("leave").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
pub fn validator_increase_lockup() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("increase_lockup").to_owned(),
        vec![],
        vec![],
    ))
}

/// Initialize the validator account and give ownership to the signing account
/// except it leaves the ValidatorConfig to be set by another entity.
/// Note: this triggers setting the operator and owner, set it to the account's address
/// to set later.
pub fn validator_initialize_stake_owner(
    initial_stake_amount: u64,
    operator: AccountAddress,
    vault: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("initialize_stake_owner").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&initial_stake_amount).unwrap(),
            bcs::to_bytes(&operator).unwrap(),
            bcs::to_bytes(&vault).unwrap(),
        ],
    ))
}

/// Initialize the validator account and give ownership to the signing account.
pub fn validator_initialize_validator(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("initialize_validator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

/// This can only called by the operator of the validator/staking lock.
pub fn validator_join_validator_set(lock_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("join_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&lock_address).unwrap()],
    ))
}

/// Request to have `lock_address` leave the validator set. The validator is only actually removed
/// from the set when the next epoch starts. The last validator in the set cannot leave. This is
/// an edge case that should never happen as long as the network is still operational.
///
/// Can only be called by the operator of the validator/staking lock.
pub fn validator_leave_validator_set(lock_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("leave_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&lock_address).unwrap()],
    ))
}

/// Add `amount` of coins from the `account` owning the StakeLock.
pub fn validator_lock_stake(amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("lock_stake").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Move `amount` of coins from pending_inactive to active.
pub fn validator_reactivate_stake(amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("reactivate_stake").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Rotate the consensus key of the validator, it'll take effect in next epoch.
pub fn validator_rotate_consensus_key(
    lock_address: AccountAddress,
    new_consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("rotate_consensus_key").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&lock_address).unwrap(),
            bcs::to_bytes(&new_consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
        ],
    ))
}

/// Allows an owner to change the operator of the stake lock.
pub fn validator_set_operator(new_operator: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("set_operator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_operator).unwrap()],
    ))
}

/// Allows an owner to change the vault of the stake lock.
pub fn validator_set_vault(new_vault: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("set_vault").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_vault).unwrap()],
    ))
}

/// Similar to unlock_with_cap but will use ownership capability from the signing account.
pub fn validator_unlock(amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("unlock").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Update the network and full node addresses of the validator. This only takes effect in the
/// next epoch.
pub fn validator_update_network_info(
    lock_address: AccountAddress,
    new_network_addresses: Vec<u8>,
    new_fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("update_network_info").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&lock_address).unwrap(),
            bcs::to_bytes(&new_network_addresses).unwrap(),
            bcs::to_bytes(&new_fullnode_addresses).unwrap(),
        ],
    ))
}

/// Withdraw from `account`'s inactive stake.
pub fn validator_withdraw(withdraw_amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator").to_owned(),
        ),
        ident_str!("withdraw").to_owned(),
        vec![],
        vec![bcs::to_bytes(&withdraw_amount).unwrap()],
    ))
}

/// Updates the major version to a larger version.
/// This can be called by on chain governance.
pub fn version_set_version(major: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("version").to_owned(),
        ),
        ident_str!("set_version").to_owned(),
        vec![],
        vec![bcs::to_bytes(&major).unwrap()],
    ))
}
mod decoder {
    use super::*;
    pub fn account_offer_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountOfferRotationCapability {
                rotation_capability_sig_bytes: bcs::from_bytes(script.args().get(0)?).ok()?,
                account_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                account_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                recipient_address: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_offer_signer_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountOfferSignerCapability {
                signer_capability_sig_bytes: bcs::from_bytes(script.args().get(0)?).ok()?,
                account_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                account_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                recipient_address: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_revoke_any_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::AccountRevokeAnyRotationCapability {})
        } else {
            None
        }
    }

    pub fn account_revoke_any_signer_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::AccountRevokeAnySignerCapability {})
        } else {
            None
        }
    }

    pub fn account_revoke_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRevokeRotationCapability {
                to_be_revoked_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_revoke_signer_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRevokeSignerCapability {
                to_be_revoked_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRotateAuthenticationKey {
                from_scheme: bcs::from_bytes(script.args().get(0)?).ok()?,
                from_public_key_bytes: bcs::from_bytes(script.args().get(1)?).ok()?,
                to_scheme: bcs::from_bytes(script.args().get(2)?).ok()?,
                to_public_key_bytes: bcs::from_bytes(script.args().get(3)?).ok()?,
                cap_rotate_key: bcs::from_bytes(script.args().get(4)?).ok()?,
                cap_update_table: bcs::from_bytes(script.args().get(5)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key_with_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::AccountRotateAuthenticationKeyWithRotationCapability {
                    rotation_cap_offerer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    new_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                    new_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                    cap_update_table: bcs::from_bytes(script.args().get(3)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn arx_account_batch_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxAccountBatchTransfer {
                recipients: bcs::from_bytes(script.args().get(0)?).ok()?,
                amounts: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn arx_account_batch_transfer_coins(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxAccountBatchTransferCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                recipients: bcs::from_bytes(script.args().get(0)?).ok()?,
                amounts: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn arx_account_create_account(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxAccountCreateAccount {
                auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn arx_account_set_allow_direct_coin_transfers(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxAccountSetAllowDirectCoinTransfers {
                allow: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn arx_account_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxAccountTransfer {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn arx_account_transfer_coins(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxAccountTransferCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn arx_coin_claim_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::ArxCoinClaimMintCapability {})
        } else {
            None
        }
    }

    pub fn arx_coin_delegate_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxCoinDelegateMintCapability {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn arx_coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ArxCoinMint {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn code_publish_package_txn(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CodePublishPackageTxn {
                metadata_serialized: bcs::from_bytes(script.args().get(0)?).ok()?,
                code: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinTransfer {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_upgrade_supply(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinUpgradeSupply {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn governance_add_approved_script_hash_script(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::GovernanceAddApprovedScriptHashScript {
                proposal_id: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn governance_create_proposal(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::GovernanceCreateProposal {
                stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
                execution_hash: bcs::from_bytes(script.args().get(1)?).ok()?,
                metadata_location: bcs::from_bytes(script.args().get(2)?).ok()?,
                metadata_hash: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn governance_create_proposal_v2(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::GovernanceCreateProposalV2 {
                stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
                execution_hash: bcs::from_bytes(script.args().get(1)?).ok()?,
                metadata_location: bcs::from_bytes(script.args().get(2)?).ok()?,
                metadata_hash: bcs::from_bytes(script.args().get(3)?).ok()?,
                is_multi_step_proposal: bcs::from_bytes(script.args().get(4)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn governance_vote(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::GovernanceVote {
                stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
                should_pass: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn lux_coin_claim_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::LuxCoinClaimMintCapability {})
        } else {
            None
        }
    }

    pub fn lux_coin_delegate_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::LuxCoinDelegateMintCapability {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn lux_coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::LuxCoinMint {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn nox_coin_claim_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::NoxCoinClaimMintCapability {})
        } else {
            None
        }
    }

    pub fn nox_coin_delegate_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::NoxCoinDelegateMintCapability {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn nox_coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::NoxCoinMint {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn object_transfer_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ObjectTransferCall {
                object_id: bcs::from_bytes(script.args().get(0)?).ok()?,
                to: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn resource_account_create_resource_account(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ResourceAccountCreateResourceAccount {
                seed: bcs::from_bytes(script.args().get(0)?).ok()?,
                optional_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn resource_account_create_resource_account_and_fund(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::ResourceAccountCreateResourceAccountAndFund {
                    seed: bcs::from_bytes(script.args().get(0)?).ok()?,
                    optional_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
                    fund_amount: bcs::from_bytes(script.args().get(2)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn resource_account_create_resource_account_and_publish_package(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::ResourceAccountCreateResourceAccountAndPublishPackage {
                    seed: bcs::from_bytes(script.args().get(0)?).ok()?,
                    metadata_serialized: bcs::from_bytes(script.args().get(1)?).ok()?,
                    code: bcs::from_bytes(script.args().get(2)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn solaris_add_coins(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SolarisAddCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn solaris_initialize_owner(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SolarisInitializeOwner {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn solaris_reactivate_coins(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SolarisReactivateCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn solaris_remove_coins(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SolarisRemoveCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn solaris_withdraw_coins(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SolarisWithdrawCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn subsidialis_join(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SubsidialisJoin {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn subsidialis_leave(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SubsidialisLeave {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn validator_increase_lockup(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::ValidatorIncreaseLockup {})
        } else {
            None
        }
    }

    pub fn validator_initialize_stake_owner(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorInitializeStakeOwner {
                initial_stake_amount: bcs::from_bytes(script.args().get(0)?).ok()?,
                operator: bcs::from_bytes(script.args().get(1)?).ok()?,
                vault: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_initialize_validator(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorInitializeValidator {
                consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
                network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_join_validator_set(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorJoinValidatorSet {
                lock_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_leave_validator_set(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorLeaveValidatorSet {
                lock_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_lock_stake(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorLockStake {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_reactivate_stake(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorReactivateStake {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_rotate_consensus_key(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorRotateConsensusKey {
                lock_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_set_operator(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorSetOperator {
                new_operator: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_set_vault(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorSetVault {
                new_vault: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_unlock(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorUnlock {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_update_network_info(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorUpdateNetworkInfo {
                lock_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_network_addresses: bcs::from_bytes(script.args().get(1)?).ok()?,
                new_fullnode_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_withdraw(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorWithdraw {
                withdraw_amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn version_set_version(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::VersionSetVersion {
                major: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "account_offer_rotation_capability".to_string(),
            Box::new(decoder::account_offer_rotation_capability),
        );
        map.insert(
            "account_offer_signer_capability".to_string(),
            Box::new(decoder::account_offer_signer_capability),
        );
        map.insert(
            "account_revoke_any_rotation_capability".to_string(),
            Box::new(decoder::account_revoke_any_rotation_capability),
        );
        map.insert(
            "account_revoke_any_signer_capability".to_string(),
            Box::new(decoder::account_revoke_any_signer_capability),
        );
        map.insert(
            "account_revoke_rotation_capability".to_string(),
            Box::new(decoder::account_revoke_rotation_capability),
        );
        map.insert(
            "account_revoke_signer_capability".to_string(),
            Box::new(decoder::account_revoke_signer_capability),
        );
        map.insert(
            "account_rotate_authentication_key".to_string(),
            Box::new(decoder::account_rotate_authentication_key),
        );
        map.insert(
            "account_rotate_authentication_key_with_rotation_capability".to_string(),
            Box::new(decoder::account_rotate_authentication_key_with_rotation_capability),
        );
        map.insert(
            "arx_account_batch_transfer".to_string(),
            Box::new(decoder::arx_account_batch_transfer),
        );
        map.insert(
            "arx_account_batch_transfer_coins".to_string(),
            Box::new(decoder::arx_account_batch_transfer_coins),
        );
        map.insert(
            "arx_account_create_account".to_string(),
            Box::new(decoder::arx_account_create_account),
        );
        map.insert(
            "arx_account_set_allow_direct_coin_transfers".to_string(),
            Box::new(decoder::arx_account_set_allow_direct_coin_transfers),
        );
        map.insert(
            "arx_account_transfer".to_string(),
            Box::new(decoder::arx_account_transfer),
        );
        map.insert(
            "arx_account_transfer_coins".to_string(),
            Box::new(decoder::arx_account_transfer_coins),
        );
        map.insert(
            "arx_coin_claim_mint_capability".to_string(),
            Box::new(decoder::arx_coin_claim_mint_capability),
        );
        map.insert(
            "arx_coin_delegate_mint_capability".to_string(),
            Box::new(decoder::arx_coin_delegate_mint_capability),
        );
        map.insert(
            "arx_coin_mint".to_string(),
            Box::new(decoder::arx_coin_mint),
        );
        map.insert(
            "code_publish_package_txn".to_string(),
            Box::new(decoder::code_publish_package_txn),
        );
        map.insert(
            "coin_transfer".to_string(),
            Box::new(decoder::coin_transfer),
        );
        map.insert(
            "coin_upgrade_supply".to_string(),
            Box::new(decoder::coin_upgrade_supply),
        );
        map.insert(
            "governance_add_approved_script_hash_script".to_string(),
            Box::new(decoder::governance_add_approved_script_hash_script),
        );
        map.insert(
            "governance_create_proposal".to_string(),
            Box::new(decoder::governance_create_proposal),
        );
        map.insert(
            "governance_create_proposal_v2".to_string(),
            Box::new(decoder::governance_create_proposal_v2),
        );
        map.insert(
            "governance_vote".to_string(),
            Box::new(decoder::governance_vote),
        );
        map.insert(
            "lux_coin_claim_mint_capability".to_string(),
            Box::new(decoder::lux_coin_claim_mint_capability),
        );
        map.insert(
            "lux_coin_delegate_mint_capability".to_string(),
            Box::new(decoder::lux_coin_delegate_mint_capability),
        );
        map.insert(
            "lux_coin_mint".to_string(),
            Box::new(decoder::lux_coin_mint),
        );
        map.insert(
            "nox_coin_claim_mint_capability".to_string(),
            Box::new(decoder::nox_coin_claim_mint_capability),
        );
        map.insert(
            "nox_coin_delegate_mint_capability".to_string(),
            Box::new(decoder::nox_coin_delegate_mint_capability),
        );
        map.insert(
            "nox_coin_mint".to_string(),
            Box::new(decoder::nox_coin_mint),
        );
        map.insert(
            "object_transfer_call".to_string(),
            Box::new(decoder::object_transfer_call),
        );
        map.insert(
            "resource_account_create_resource_account".to_string(),
            Box::new(decoder::resource_account_create_resource_account),
        );
        map.insert(
            "resource_account_create_resource_account_and_fund".to_string(),
            Box::new(decoder::resource_account_create_resource_account_and_fund),
        );
        map.insert(
            "resource_account_create_resource_account_and_publish_package".to_string(),
            Box::new(decoder::resource_account_create_resource_account_and_publish_package),
        );
        map.insert(
            "solaris_add_coins".to_string(),
            Box::new(decoder::solaris_add_coins),
        );
        map.insert(
            "solaris_initialize_owner".to_string(),
            Box::new(decoder::solaris_initialize_owner),
        );
        map.insert(
            "solaris_reactivate_coins".to_string(),
            Box::new(decoder::solaris_reactivate_coins),
        );
        map.insert(
            "solaris_remove_coins".to_string(),
            Box::new(decoder::solaris_remove_coins),
        );
        map.insert(
            "solaris_withdraw_coins".to_string(),
            Box::new(decoder::solaris_withdraw_coins),
        );
        map.insert(
            "subsidialis_join".to_string(),
            Box::new(decoder::subsidialis_join),
        );
        map.insert(
            "subsidialis_leave".to_string(),
            Box::new(decoder::subsidialis_leave),
        );
        map.insert(
            "validator_increase_lockup".to_string(),
            Box::new(decoder::validator_increase_lockup),
        );
        map.insert(
            "validator_initialize_stake_owner".to_string(),
            Box::new(decoder::validator_initialize_stake_owner),
        );
        map.insert(
            "validator_initialize_validator".to_string(),
            Box::new(decoder::validator_initialize_validator),
        );
        map.insert(
            "validator_join_validator_set".to_string(),
            Box::new(decoder::validator_join_validator_set),
        );
        map.insert(
            "validator_leave_validator_set".to_string(),
            Box::new(decoder::validator_leave_validator_set),
        );
        map.insert(
            "validator_lock_stake".to_string(),
            Box::new(decoder::validator_lock_stake),
        );
        map.insert(
            "validator_reactivate_stake".to_string(),
            Box::new(decoder::validator_reactivate_stake),
        );
        map.insert(
            "validator_rotate_consensus_key".to_string(),
            Box::new(decoder::validator_rotate_consensus_key),
        );
        map.insert(
            "validator_set_operator".to_string(),
            Box::new(decoder::validator_set_operator),
        );
        map.insert(
            "validator_set_vault".to_string(),
            Box::new(decoder::validator_set_vault),
        );
        map.insert(
            "validator_unlock".to_string(),
            Box::new(decoder::validator_unlock),
        );
        map.insert(
            "validator_update_network_info".to_string(),
            Box::new(decoder::validator_update_network_info),
        );
        map.insert(
            "validator_withdraw".to_string(),
            Box::new(decoder::validator_withdraw),
        );
        map.insert(
            "version_set_version".to_string(),
            Box::new(decoder::version_set_version),
        );
        map
    });
